"""
ACCESS THE DRAW.IO TEMPLATE AT
https://viewer.diagrams.net/index.html?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=template.xml#R7ZtZc9pIEMc%2FDY%2Bo5tbo0diOk80m2Yqzce2%2B6RhAGyFphWTjfPr06AAJjfHaQDg2UAWiZ3RM%2F6a7%2FyPLA3o5W9xkbjr9kAQqGhAULAb0akAIxgTDl7Y8Vhab08owycKg7rQy3IbfVW1EtbUIAzXvdMyTJMrDtGv0kzhWft6xuVmWPHS7jZOoe9bUnaie4dZ3o771LgzyaWWVHK3sb1U4mTZnZqhumblN59own7pB8tAy0esBvcySJK%2B2ZotLFWnnNX6p9nvzROvywjIV5%2F9lhyCZfEiT9O4feWN7w3vPu%2Fr7cVjDuHejoh7wgIgIjjcqYF8x0VuNJQrXLfPUjfXI8sfaXeLfQg9nNE7ifDgvYV5AB8LSRbkbKhseaofpJhv8VbbkapEP3SicxFWDD8NSWavtASZY1RQn1fZodcLmykblOHSnu2kCF0XQrZ8pFTdXDO6pLro7EDD3R3cK470pB1f2uoRTuWEMxzjTsX7K3HhSn%2FUWsoLnns1Qkef63yZZUsTB0E%2BiJKt6hHGYh25k9MYfRZZGqkEfFbN4%2Fow3vOxk%2FbM%2B%2BL8gtelcqrt9CXMd6OcxEdYH%2BlkFVZ93cVrk8K0iNYMjPcd62wE%2FPx%2FRa31iDoAN7lr3yd00zOuTXsSP%2BjjuDNykNcAsTWJdDncSCGBsF0HScRTRF6w9mGfJN3VZ%2BegqhtPr6RJG0Zppms%2FAb1cYNh%2F09d%2Bmrq%2BPVHvgXmV5CKrjovLA1SwMAn2mUQIt43KuX03BppP9qF%2F5azGgj6IWLVOtBG5UMlN5pn31sBIxrBEx05aAWcoVtxZOk%2BW%2BK20BG7W8MEuNz9dvZTqU3pTdfv1e0M%2FvR3fFkPWkxsdPX65rjuXu4MvCz4vMjdow56V2SopII%2FZ0SY8S381L4mE8h0KgrzaGn2%2FA4QQlcakRU7051ptT3cHTZ9V5dq6%2F5rUoaMLJquZSPg3jibbel42u9nK4KBVtUuT1qeqDunnpzfLCy6vK1AxgBVZvppRhpOP4Cj1BvzU5tmFbtzIhLV7tVIvuhmkLPkW46TTt6tft8d%2B8456SH68%2FjD6O4lGByeLbeIh7%2BLdzVDvGBoQGrpJjvxeQ0CJ8qbwxtIQzEOsX87RaJuDG0sh6wsDiL0VUdRG7wIG6LFgfhi0MkbhcSewcBdkvivFYCd%2BIIrAdr6wFx4sC29yikgnMq0%2F2M8H0V2Nf1CyNINlpyZtnyp1Foc47F2m6AdlTRWYTsjF5ApnwBBeHQ0awXGNGesy4NISP2Bekfh2bR1AZsu2AvMa96xClr8wQPcl1sd8JEM6sZXCUnx081BRSTFidPYRBdkDJsjEjsvmke6LHf9HbQE8SS7Y4OMfNUvxi%2BTRLRrjVpiCPmyW2ezBLt2%2BnTA5UtDaT0c2kHWavQ8Ntqw0GdtkejXHh9iLl%2FnLtoXDAlW0KFkfY1D2k9iBdvWgqbjrMKDYEjrMD%2FWG8Zb9nHABDBsyEQxKPioPicLoZTtpWM%2Fg2EcQtIftEMOUWk%2FtKX87%2FmIolyVqccEvaLwBjW2gHyevreyqjP4u739K78ci2f%2Fe%2Fu5OXrXX3krx24GNqU4s74CdECcPLRWnjboGhElC0fNF%2BPcHCYg5yHCQERY5khnqCMbJsgqCWiOrF9xQr51TptWK2BUMYE8dhlK%2FpaQFCANHVi%2FfIOBLYOZiDKADMTYbrcEHUkoBu9dpTqPTl9AmGCkfMYpwyQQm2qeBrscIcx%2BIgqgDcU0QOFStGJv3l6gky2Zy%2BjhiJudSjM8pfHFNLEIczieCHI7sKi0PqQVisXkedv%2Fo35k4wVmBBAdPYIbYNFV2K5mmpU42V%2FmLldGNlc60%2F2lgxg%2Bnr4tMFA1nMkjDTbcZtQexmbMcOxpjEDn%2BzZSdJDLzFJId%2BnEjq2B0gR7xeMSIxPSN5ckie0cVHzMScv%2FpQzjV%2FHe0i0gymr8JOF8xmdXy0YIx38Q9%2FI%2BxAEIV4%2Fi4%2BpqZH4XZxC98YJPKMYkTYCArL6r2WvMpbwS311b8tjJFjIaf1tg1RQqXFcCvU9gSmfxf%2FXMFw%2FfyfbKli9jowBHQDbvHdlwgzrCSD8P6Zv%2Fb%2FnOct1x8ro5hZvD%2FPOTPkGMwt9vLJDD9X%2FzdUtrX%2B%2B4pe%2FwA%3D#%7B%22pageId%22%3A%222R-bZ0T-rrXWbhNSETN-%22%7D
"""


from lxml import etree
from pprint import pprint

with open('test_app.xml', 'rb') as f:
    data = f.read()

root = etree.fromstring(data)
elements = root.xpath("//mxCell[string-length(@id) > 1 and string-length(@value) < 40]")

get_id = etree.XPath("@id")
get_value = etree.XPath("@value")
get_x = etree.XPath("mxGeometry/@x")
get_y = etree.XPath("mxGeometry/@y")
get_w = etree.XPath("mxGeometry/@width")
get_h = etree.XPath("mxGeometry/@height")
get_style = etree.XPath("@style")

class_dict = {
    "#dae8fc": "window",
    "#ffe6cc": "sidebar",
    "#fff2cc": "title",
    "#d5e8d4": "container",
    "#e1d5e7": "column",
    "#f8cecc": "input"
}

TAB = "\t"

def get_class(el: etree.Element) -> str:
    style = get_style(el)[0]
    style_lst = style.split(";")
    for item in style_lst:
        if "=" in item:
            key, val = item.split("=")
            if key == "fillColor":
                return class_dict[val]
        
    return "component"

def get_data(el: etree.Element) -> dict:
    width = float(get_w(el)[0])
    height = float(get_h(el)[0])
    size = width*height

    return {
            "id": get_id(el)[0],
            "value": get_value(el)[0].lower(),
            "x": float(get_x(el)[0]),
            "y": float(get_y(el)[0]),
            "w": width,
            "h": height,
            "size": size,
            "class": get_class(el),
        }

def contains(el1: dict,el2: dict) -> bool:
    if el1['x'] <= el2['x'] and el1['y'] <= el2['y']:
        if el2['x'] + el2['w'] <= el1['x'] + el1['w'] and el2['y'] + el2['h'] <= el1['y'] + el1['h']:
            return True
    return False


element_data = [get_data(el) for el in elements]
element_data = sorted(element_data, key=lambda x: x["size"], reverse=True)

columns = [col for col in element_data if col['class'] == 'column']
column_dict = {col['id']:f"col{i}" for i, col in enumerate(columns)}
inputs = [inp for inp in element_data if inp['class'] == 'input']
input_dict = {inp['id']:f"input{i}" for i, inp in enumerate(inputs)}

for i in range(len(element_data)):
    element_data[i]["children"] =  []

i = len(element_data)-2
while i > -1 and len(element_data) > 1:
    for j in range(len(element_data)-1, i, -1):
        if contains(element_data[i], element_data[j]):
            element_data[i]["children"].append(element_data[j])
            element_data.pop(j)
    i -= 1

element_tree = element_data[0]
pprint(element_tree)

print("\n","="*80,"\n")

def recursive_streamlit(el_dict, col_count=[0], indent = 0):
    children = el_dict['children']
    if not len(children):
        if el_dict['class'] == "component":
            if el_dict['value'] == "image":
                return [f'{indent * TAB}st.image("default.png")']
            else:
                return [f'{indent * TAB}st.{el_dict["value"]}()']
        elif el_dict['class'] == "input":
            return [f'{indent * TAB}st.{el_dict["value"]}(label=\"{el_dict["id"]}\")']
        elif el_dict['class'] == "title":
            return [f'{indent * TAB}st.title(\"{el_dict["value"].capitalize()}\")']
        else:
            print("The element below was expecting to have at least one child element.")
            print(el_dict)
            return []

    if el_dict['class'] == "window":
        code = [f'{indent * TAB}st.set_page_config(layout="wide")\n']
        children = sorted(children, key=lambda x: (x['y'], x['x']))
    elif el_dict['class'] == "container":
        code = [f'{indent * TAB}with st.container():']
        indent += 1
        children = sorted(children, key=lambda x: (x['y'], x['x']))
    elif el_dict['class'] == "sidebar":
        code = [f"{indent*TAB}with st.sidebar:"]
        indent += 1
        children = sorted(children, key=lambda x: (x['y'], x['x']))
    else:
        code = []

    for child in children:
        try:
            if child['class'] != "column":
                code += recursive_streamlit(child, col_count, indent)
            else:
                columns = [el for el in children if el['class']=='column']
                vars = ", ".join([f"{columns[i]['id']}" for i in range(len(columns))])
                code += [f"{indent * TAB}{vars} = st.columns({str([round(col['w']) for col in columns])})"]
                for i, col in enumerate(columns):
                    code += [f"{indent * TAB}with {col['id']}:"]
                    col_count[0] += 1
                    code += recursive_streamlit(col, col_count, indent+1)
                for col in columns:
                    children.remove(col)
        except Exception as e:
            print(e)
            print("columns already handled")

    return code

code = recursive_streamlit(element_tree)
code = ["import streamlit as st\n"] + code
code_string = "\n".join(code)

for id in column_dict:
    code_string = code_string.replace(id, column_dict[id])

for id in input_dict:
    code_string = code_string.replace(id, input_dict[id])

print(code_string)